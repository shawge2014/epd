let PCF_DEBUG=!1,pcfLog=(...t)=>{PCF_DEBUG&&console.log(...t)},pcfWarn=(...t)=>{PCF_DEBUG&&console.warn(...t)};class PCFFont{constructor(){this.fonts=new Map,this.isLittleEndian=!0}async load(e,t){try{var n,r,a=await fetch(t);if(a.ok)return n=await a.arrayBuffer(),r=this.parsePCF(n),this.fonts.set(e,r),pcfLog(`PCF font loaded: ${e} from `+t),r;throw new Error("Failed to load font: "+t)}catch(t){throw console.error(`Error loading PCF font ${e}:`,t),t}}parsePCF(t){var e=new DataView(t);let n=0;t=e.getUint32(n,!0);if(n+=4,1885562369!==t)throw new Error("Invalid PCF file signature");var r=e.getUint32(n,!0),a=(n+=4,{});for(let t=0;t<r;t++){var i=e.getUint32(n,!0),o=e.getUint32(n+4,!0),s=e.getUint32(n+8,!0),g=e.getUint32(n+12,!0);g>=e.byteLength?(pcfWarn(`Table type ${i.toString(16)} has invalid offset ${g}, skipping`),n+=16):(a[i]={format:o,size:s,offset:g},pcfLog(`Table type: 0x${i.toString(16).padStart(2,"0")}, offset: ${g}, size: `+s),n+=16)}t={glyphs:new Map,metrics:{},defaultChar:0,encoding:{},view:e};return a[4]&&this.parseMetrics(e,a[4],t),a[8]&&this.parseBitmaps(e,a[8],t),a[32]&&this.parseEncoding(e,a[32],t),a[256]&&this.parseBDFAccelerators(e,a[256],t),t}getEndianness(t){return 0==(4&t)}parseMetrics(o,t,s){let g=t.offset;var t=o.getUint32(g,!0),h=(g+=4,this.getEndianness(t)),f=0!=(256&t),e=f?o.getUint16(g,h):o.getUint32(g,h);g+=f?2:4,s.metricsData=[];for(let t=0;t<e;t++){let t,e,n,r,a,i;f?(t=o.getUint8(g++)-128,e=o.getUint8(g++)-128,n=o.getUint8(g++)-128,r=o.getUint8(g++)-128,a=o.getUint8(g++)-128,i=0):(t=o.getInt16(g,h),g+=2,e=o.getInt16(g,h),g+=2,n=o.getInt16(g,h),g+=2,r=o.getInt16(g,h),g+=2,a=o.getInt16(g,h),g+=2,i=o.getUint16(g,h),g+=2),s.metricsData.push({leftBearing:t,rightBearing:e,width:n,ascent:r,descent:a,attributes:i})}}parseBitmaps(e,t,n){let r=t.offset;var a=e.getUint32(r,!0),i=(r+=4,this.getEndianness(a));if(r+4>e.byteLength)throw new Error("Not enough data to read bitmap count");var o=e.getUint32(r,i),s=(r+=4,3&a),g=1<<s,h=4&a?"MSB":"LSB",f=8&a?"MSB":"LSB",p=a>>4&3,c=1<<p,d=(n.bitmapFormat={format:a,glyphPadCode:s,glyphPadBytes:g,scanUnitCode:p,scanUnitBytes:c,byteOrder:h,bitOrder:f},pcfLog(`Bitmap table: glyphCount=${o}, format=0x${a.toString(16)}, `+`glyphPad=${g}, scanUnit=${c}, byteOrder=${h}, bitOrder=`+f),[]),l=Math.min(r+4*o,t.offset+t.size);for(let t=0;t<o;t++){if(r+4>l){pcfWarn(`Warning: Not enough data for bitmap offset ${t}, stopping`);break}d.push(e.getUint32(r,i)),r+=4}var y=[];for(let t=0;t<4;t++)r+4>e.byteLength?y.push(0):(y.push(e.getUint32(r,i)),r+=4);p=r,a=t.offset+t.size-p,g=Math.min(y[s]||y[0]||0,a);pcfLog(`Bitmap data: start=${p}, size=${g}, tableEnd=`+(t.offset+t.size)),0<g&&p+g<=e.byteLength?n.bitmapData=new Uint8Array(e.buffer,p,g):(pcfWarn("Invalid bitmap data size, using empty array"),n.bitmapData=new Uint8Array(0)),n.bitmapOffsets=d,n.bitmapDataOffset=p}parseEncoding(e,t,n){let r=t.offset;var t=e.getUint32(r,!0),a=(r+=4,this.getEndianness(t)),t=e.getUint16(r,a),i=(r+=2,e.getUint16(r,a)),o=(r+=2,e.getUint16(r,a)),s=(r+=2,e.getUint16(r,a)),g=(r+=2,e.getUint16(r,a)),h=(r+=2,n.encoding={minCharOrByte2:t,maxCharOrByte2:i,minByte1:o,maxByte1:s,defaultChar:g},[]),f=(i-t+1)*(s-o+1);pcfLog(`Encoding table: byte1=[${o}-${s}], byte2=[${t}-${i}], glyphCount=`+f);for(let t=0;t<f;t++){var p=e.getUint16(r,a);h.push(65535===p?-1:p),r+=2}n.glyphIndices=h}parseBDFAccelerators(t,e,n){var e=e.offset,r=t.getUint32(e,!0),r=(e+=4,this.getEndianness(r)),a=t.getInt32(e+=8,r),i=t.getInt32(e+=4,r),t=t.getInt32(e+=4,r);n.metrics={fontAscent:a,fontDescent:i,maxOverlap:t,lineHeight:a+i}}getGlyphIndex(i,t){let{minCharOrByte2:o,maxCharOrByte2:s,minByte1:g,maxByte1:h,defaultChar:e}=i.encoding,f=(i._encodingInfoLogged||(pcfLog("=== Font Encoding Info ==="),pcfLog(`  byte1 range: 0x${g.toString(16)} - 0x${h.toString(16)} (${g} - ${h})`),pcfLog(`  byte2 range: 0x${o.toString(16)} - 0x${s.toString(16)} (${o} - ${s})`),pcfLog("  glyphIndices length: "+i.glyphIndices.length),i._encodingInfoLogged=!0),s-o+1);var n=(t,e,n)=>{var r,a;return!(t<g||t>h||e<o||e>s||(r=e-o,(r=(t-g)*f+r)<0)||r>=i.glyphIndices.length||-1===(a=i.glyphIndices[r]))?(i._firstGlyphHitLogged||(pcfLog(`    Glyph hit (${n}): byte1=0x${t.toString(16)}, byte2=0x${e.toString(16)}, index=${r}, glyphIndex=`+a),i._firstGlyphHitLogged=!0),a):-1};if(t<256){var r=n(0,t,"ASCII");if(-1!==r)return r}else{r=n(t>>8&255,255&t,"Unicode");if(-1!==r)return r}if(19968<=t&&t<=40959){r=this.unicodeToGB2312(t);if(0<r){var a=r>>8&255,p=255&r,t=(pcfLog(`    Unicode 0x${t.toString(16)} -> GB 0x${r.toString(16)} (byte1=0x${a.toString(16)}, byte2=0x${p.toString(16)})`),n(a,p,"GBK"));if(-1!==t)return t}}if("number"==typeof e){r=n(e>>8&255,255&e,"defaultChar");if(-1!==r)return r}return-1}unicodeToGB2312(e){try{var t=String.fromCharCode(e),n=this.encodeGBK(t);if(n&&2<=n.length)return n[0]<<8|n[1]}catch(t){pcfWarn("Failed to convert unicode to GB2312:",e)}return-1}encodeGBK(t){var e=this.getCommonChineseMap();return e.has(t)?[(e=e.get(t))>>8,255&e]:null}getCommonChineseMap(){return this.chineseMap||(this.chineseMap=new Map([["周",55004],["一",53947],["二",46846],["三",51453],["四",52164],["五",52965],["六",49657],["日",51413],["天",52460],["期",50906],["第",46554],["节",48602],["零",49635],["七",50911],["八",45259],["九",48837],["十",51889],["语",54255],["文",52932],["数",51965],["学",53671],["英",54178],["理",49389],["化",48047],["生",51706],["物",52975],["政",54782],["治",54990],["历",49402],["史",51895],["地",46552],["体",52453],["育",54269],["音",54004],["乐",49366],["美",50112],["术",51957],["信",53445],["息",53154],["技",48316],["课",49094]])),this.chineseMap}renderText(e,t,n,r,a,i="#000000"){var o=this.fonts.get(t);if(!o)return pcfWarn("Font not loaded: "+t),0;this.debugOutputDone||(pcfLog(`=== First render debug for ${t} ===`),pcfLog(`Encoding: byte1=[0x${o.encoding.minByte1.toString(16)}-0x${o.encoding.maxByte1.toString(16)}], byte2=[0x${o.encoding.minCharOrByte2.toString(16)}-0x${o.encoding.maxCharOrByte2.toString(16)}]`),this.debugOutputDone=!0);let s=r;var g="周一"===n;g&&pcfLog(`Rendering text: "${n}"`);for(let t=0;t<n.length;t++){var h,f,p,c=n[t],d=n.charCodeAt(t),l=this.getGlyphIndex(o,d);g&&pcfLog(`  Char: "${c}" (U+${d.toString(16).toUpperCase().padStart(4,"0")}) -> glyphIndex: `+l),l<0||l>=o.metricsData.length?g&&pcfWarn(`  Invalid glyph index for char "${c}"`):(d=o.metricsData[l],c=o.bitmapOffsets[l],l=d.rightBearing-d.leftBearing,h=d.ascent+d.descent,l<=0||h<=0||(f=Math.round(s+d.leftBearing),p=Math.round(a-d.ascent),this.renderGlyph(e,o,c,l,h,f,p,i)),s+=d.width)}return s-r}renderGlyph(t,e,r,a,i,n,o,s){var g=e.bitmapData,h=e.bitmapFormat||{glyphPadBytes:1,scanUnitBytes:1,byteOrder:"MSB",bitOrder:"MSB"},e=Math.ceil(a/8),f=Math.ceil(e/h.glyphPadBytes)*h.glyphPadBytes,e=t.createImageData(a,i),p=e.data;for(let t=0;t<p.length;t+=4)p[t]=255,p[t+1]=255,p[t+2]=255,p[t+3]=255;var c=this.parseColor(s);for(let n=0;n<i;n++){var d=r+n*f;for(let e=0;e<a;e++){let t=Math.floor(e/8);var l,y,u=d+(t=1<h.scanUnitBytes&&(u=Math.floor(t/h.scanUnitBytes)*h.scanUnitBytes,l=t%h.scanUnitBytes,"LSB"===h.byteOrder)?u+(h.scanUnitBytes-1-l):t);u>=g.length||(l=e%8,y="MSB"===h.bitOrder?7-l:l,g[u]>>y&1&&(p[y=4*(n*a+e)]=c.r,p[1+y]=c.g,p[2+y]=c.b,p[3+y]=255))}}t.putImageData(e,n,o)}measureText(t,e){var n=this.fonts.get(t);if(!n)return 0;let r=0;for(let t=0;t<e.length;t++){var a=e.charCodeAt(t),a=this.getGlyphIndex(n,a);0<=a&&a<n.metricsData.length&&(r+=n.metricsData[a].width)}return r}getFontMetrics(t){t=this.fonts.get(t);return t?t.metrics:null}parseColor(t){return t.startsWith("#")?(t=t.substring(1),{r:parseInt(t.substring(0,2),16),g:parseInt(t.substring(2,4),16),b:parseInt(t.substring(4,6),16)}):{r:0,g:0,b:0}}isLoaded(t){return this.fonts.has(t)}}let pcfFontManager=new PCFFont;